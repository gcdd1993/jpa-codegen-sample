这是[jpa-codegen](https://github.com/gcdd1993/jpa-codegen)的使用示例仓库。

# SpringBoot2.x

我们想要使用jpa-codegen来生成CRUD代码，是十分简单的。

## 创建Gradle项目，并添加build.gradle如下

```groovy
buildscript {
    ext {
        springBootVersion = '2.1.8.RELEASE'
        querydslVersion = '4.2.1'
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}"
        classpath 'gradle.plugin.com.ewerk.gradle.plugins:querydsl-plugin:1.0.10'
        classpath 'io.franzbecker:gradle-lombok:3.1.0'
        classpath 'io.spring.gradle:dependency-management-plugin:1.0.8.RELEASE'
    }
    repositories {
        jcenter()
        maven { url "https://plugins.gradle.org/m2/" }
        maven { url "http://repo.spring.io/libs-snapshot" }
        maven { url "https://mvnrepository.com" }
        mavenCentral()
    }
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
apply plugin: "io.franzbecker.gradle-lombok"
apply plugin: "com.ewerk.gradle.plugins.querydsl"

group 'com.maxtropy'
version "v0.1.0"

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
}

querydsl {
    jpa = true
}

configurations {
    querydsl.extendsFrom compileClasspath
}

compileQuerydsl {
    options.annotationProcessorPath = configurations.querydsl
}

repositories {
    mavenLocal()
    maven() {
        url 'http://maven.aliyun.com/nexus/content/groups/public/'
    }
    maven() {
        url 'http://unidal.org/nexus/content/repositories/releases/'
    }
    maven {
        url 'https://dl.bintray.com/gcdd1993/maven'
    }
    jcenter()
    mavenCentral()
}

dependencies {
    compile 'org.springframework.boot:spring-boot-starter-data-jpa'
    compile 'org.springframework.boot:spring-boot-starter-web'

    // querydsl
    compile 'com.querydsl:querydsl-jpa'

    // jpa
    runtime 'org.postgresql:postgresql'
    compile 'org.hibernate:hibernate-java8'
    compile 'com.zaxxer:HikariCP'

    testCompile 'org.springframework.boot:spring-boot-starter-test'

    // jpa code generator
    testCompile 'io.github.gcdd1993:jpa-codegen:v1.0.1'
    testCompile 'org.freemarker:freemarker:2.3.28'
}
```

## 创建实体类SampleUser

```java
package me.itlearner.jpacodegen.sample.entity;

import lombok.Data;

import javax.persistence.*;

/**
 * TODO
 *
 * @author gaochen
 * @date 2019/9/5
 */
@Entity
@Table
@Data
public class SampleUser {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String username;

    private String password;
}
```

## 配置代码模板

比如，我要生成repo（JpaRepository），service（业务层），controller（控制层）以及form（表单）我可以配置4个[代码模板](https://github.com/gcdd1993/jpa-codegen-sample/tree/master/jpa-codegen-sample-2/src/test/resources/template)，代码模板可以根据自己需要自行修改。

![](https://i.loli.net/2019/09/10/7yXrCWVdp1cxAFU.png)

## 配置[jpa-codegen](https://github.com/gcdd1993/jpa-codegen)生成器

```properties
author=generated by jpa codegen
comments=TODO
cover=true
template.dir=src/test/resources/template/
## the following config is module config list, you must have the ftl file for every module
repository.suffix=Repository
repository.template=repository.ftl
repository.flag=entity.repo
service.suffix=Service
service.template=service.ftl
service.flag=service
form.suffix=Form
form.template=form.ftl
form.flag=form
controller.suffix=Controller
controller.template=controller.ftl
controller.flag=web
```

## 开始生成

在test模块中编写生成器入口类，如

```java
@Test
public void generate() {
    new CodeGenerator("src/test/resources/codegen.properties")
        .packInclude("me.itlearner.jpacodegen.sample.entity") // 批量加入生成的实体类包名
        // .clazzInclude(me.itlearner.jpacodegen.sample.entity.SampleUser.class) // 加入生成的实体类名
        // .clazzExlude(me.itlearner.jpacodegen.sample.entity.SampleUser.class) // 排除生成的实体类名，通常与packInclude混用，以排除包下的特殊实体类不参与生成代码
        .registerRender("form")
        .registerRender("repository")
        .registerRender("service")
        .registerRender("controller")
        .generate();
}
```

然后运行，可以发现，`repo，form，service，web`4个包下会自动生成对应的代码，

![](https://i.loli.net/2019/09/10/BRS6VPNfCdkTjJm.png)

由于使用到了[Querydsl](http://www.querydsl.com/)，我们还要运行下Gradle任务`compileQuerydsl`，生成对应的Query类

![](https://i.loli.net/2019/09/10/fiCSsoQP4EukvwH.png)

## 配置数据库连接信息

```yaml
spring:
  application:
    name: sample-springboot-1.x
  ## JPA 配置
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        jdbc:
          time_zone: UTC
  #        format_sql: true
  #        show_sql: true
  datasource:
    username: postgres
    password: postgres
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://192.168.222.129:5432/postgres
    hikari:
      maximum-pool-size: 3

  ## Jackson 配置
  jackson:
    serialization:
      WRITE_DATES_AS_TIMESTAMPS: false
    property-naming-strategy: SNAKE_CASE
```

## 运行项目

至此，一个完整的CRUD项目就完成了，我们点击SpringBoot主类测试下我们的接口吧

### 新增用户

![](https://i.loli.net/2019/09/10/QLgZn39R2xAfCod.png)

我们去数据库查看下

![](https://i.loli.net/2019/09/10/4qLgkT8Hs6WhrC5.png)

发现，确实新增了一个用户，代表我们的新增用户接口是没问题的。

## 修改用户

我们修改下刚才添加的用户

![](https://i.loli.net/2019/09/10/rpIvFV6sknYhb8J.png)

查看下数据库

![](https://i.loli.net/2019/09/10/UvBPfi76FEpa4ew.png)

没毛病。

## 分页接口

![](https://i.loli.net/2019/09/10/adWVmfjGOgQp6BY.png)

## 删除接口

![](https://i.loli.net/2019/09/10/meS9OdVvuQGMoZr.png)

查看数据库

![](https://i.loli.net/2019/09/10/NGqucVSP4kO6D59.png)

确实删除了。
这样写CRUD，是不是很方便呢？

# SpringBoot1.x

